// Package etag provides functions for parsing and generating globally unique
// ETags from a UUID and updated-at timestamp.
//
// Tags generated by this package are designed to support optimistic concurrency
// control at the web server and database levels without requiring a full hash
// of the resource or any additional data to be persisted.
//
// For Postgres, the resolution of the timestamp field is 1 microsecond, which
// is sufficient for all expected workloads.
package etag

import (
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
)

type ETag struct {
	id        uuid.UUID
	updatedAt time.Time
}

const (
	eTagSeparator = ";"
	eTagFormat    = `"00000000-0000-0000-0000-000000000000;2006-01-02T15:04:05.999999999Z07:00"`
)

type ParseETagError struct {
	RawETag string
	Cause   error
}

func (e *ParseETagError) Error() string {
	return fmt.Sprintf("ETag %s was not in the expected format %s: %s", e.RawETag, eTagFormat, e.Cause)
}

func ParseETag(raw string) (ETag, error) {
	if !strings.HasPrefix(raw, `"`) || !strings.HasSuffix(raw, `"`) {
		return ETag{}, &ParseETagError{
			RawETag: raw,
			Cause: fmt.Errorf(
				"expected double-quoted string, got %s",
				raw,
			),
		}
	}

	unquoted := strings.Trim(raw, `"`)
	components := strings.Split(unquoted, eTagSeparator)
	if len(components) != 2 {
		return ETag{}, &ParseETagError{
			RawETag: raw,
			Cause: fmt.Errorf(
				"expected %d components with separtor %q, got %d",
				2,
				eTagSeparator,
				len(components),
			),
		}
	}

	id, err := uuid.Parse(components[0])
	if err != nil {
		return ETag{}, &ParseETagError{RawETag: raw, Cause: err}
	}

	updatedAt, err := time.Parse(time.RFC3339Nano, components[1])
	if err != nil {
		return ETag{}, &ParseETagError{RawETag: raw, Cause: err}
	}

	return ETag{
		id:        id,
		updatedAt: updatedAt,
	}, nil
}

func (e ETag) String() string {
	var builder strings.Builder
	builder.WriteByte('"')
	builder.WriteString(e.id.String())
	builder.WriteString(eTagSeparator)
	builder.WriteString(e.updatedAt.Format(time.RFC3339Nano))
	builder.WriteByte('"')
	return builder.String()
}
